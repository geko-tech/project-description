import Foundation

// WARNING!!!!! ACHTUNG!!!!
// When adding or changing fields of Target struct, please
// ensure that `func encode(to: Encoder)` and `init(from: Decoder)`
// are working properly and don't forget to
// change tests ProjectDescriptionTests.TargetTests accordingly!


/// A target of a project.
public struct Target: Codable, Equatable, Hashable, Comparable {
    /// The name of the target. Also, the product name if not specified with ``productName``.
    public var name: String

    /// The destinations this target supports, e.g. iPhone, appleVision, macCatalyst
    public var destinations: Destinations

    /// The type of build product this target will output.
    public var product: Product

    /// The built product name. If nil, it will be equal to ``name``.
    public var productName: String

    /// The product bundle identifier.
    public var bundleId: String?

    /// The minimum deployment targets your product will support.
    public var deploymentTargets: DeploymentTargets

    /// The Info.plist representation.
    public var infoPlist: InfoPlist?

    /// Buildable folders of the target.
    public var buildableFolders: [BuildableFolder]

    /// The source files of the target.
    /// Note: any playgrounds matched by the globs used in this property will be automatically added.
    public var sources: [SourceFiles]

    public var playgrounds: [FilePath]

    /// The resource files of target.
    /// Note: localizable files, `*.lproj`, are supported.
    public var resources: [ResourceFileElement]

    /// The build phase copy files actions for the target.
    public var copyFiles: [CopyFilesAction]

    /// The headers for the target.
    public var headers: HeadersList?

    /// The entitlements representation
    public var entitlements: Entitlements?

    /// The build phase scripts actions for the target.
    public var scripts: [TargetScript]

    /// The target's dependencies.
    public var dependencies: [TargetDependency]

    /// Dependencies to ignore. Can be useful to disable unwanted transitive dependency.
    public var ignoreDependencies: [TargetDependency]
    /// Dependencies to prioritize in link phase. Every dependency listed here will be
    /// at the start of the 'Link Binary With Libraries' phase in the same order.
    public var prioritizeDependencies: [TargetDependency]

    /// The target's settings.
    public var settings: Settings?

    /// The Core Data models.
    public var coreDataModels: [CoreDataModel]

    /// The environment variables. Used by autogenerated schemes for the target.
    public var environmentVariables: [String: EnvironmentVariable]

    /// The launch arguments. Used by autogenerated schemes for the target.
    public var launchArguments: [LaunchArgument]

    /// The additional files for the target. For project's additional files, see ``Project/additionalFiles``.
    public var additionalFiles: [FileElement]

    /// These files will be created before project generation
    public var preCreatedFiles: [String]

    /// The build rules used for transformation of source files during compilation.
    public var buildRules: [BuildRule]

    /// Specifies whether if the target can merge or not the dynamic dependencies as part of its binary
    public var mergedBinaryType: MergedBinaryType

    /// Specifies whether if the target can be merged as part of another binary or not
    public var mergeable: Bool

    public var filesGroup: ProjectGroup

    public var prune: Bool

    enum CodingKeys: String, CodingKey {
        case name
        case destinations
        case product
        case productName
        case bundleId
        case deploymentTargets
        case infoPlist
        case buildableFolders
        case sources
        case playgrounds
        case resources
        case copyFiles
        case headers
        case entitlements
        case scripts
        case dependencies
        case ignoreDependencies
        case prioritizeDependencies
        case settings
        case coreDataModels
        case environmentVariables
        case launchArguments
        case additionalFiles
        case preCreatedFiles
        case buildRules
        case mergedBinaryType
        case mergeable
        case filesGroup
        case prune
    }

    public init(
        name: String,
        destinations: Destinations,
        product: Product,
        productName: String? = nil,
        bundleId: String? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        infoPlist: InfoPlist? = .default,
        buildableFolders: [BuildableFolder] = [],
        sources: SourceFilesList? = nil,
        playgrounds: [FilePath] = [],
        resources: ResourceFileElements? = nil,
        copyFiles: [CopyFilesAction]? = nil,
        headers: HeadersList? = nil,
        entitlements: Entitlements? = nil,
        scripts: [TargetScript] = [],
        dependencies: [TargetDependency] = [],
        ignoreDependencies: [TargetDependency] = [],
        prioritizeDependencies: [TargetDependency] = [],
        settings: Settings? = nil,
        coreDataModels: [CoreDataModel] = [],
        environmentVariables: [String: EnvironmentVariable] = [:],
        launchArguments: [LaunchArgument] = [],
        additionalFiles: [FileElement] = [],
        preCreatedFiles: [String] = [],
        buildRules: [BuildRule] = [],
        mergedBinaryType: MergedBinaryType = .disabled,
        mergeable: Bool = false,
        filesGroup: ProjectGroup = .group(name: "Project")
    ) {
        self.name = name
        self.destinations = destinations
        self.bundleId = bundleId
        self.productName = productName ?? name.replacingOccurrences(of: "-", with: "_")
        self.product = product
        self.infoPlist = infoPlist
        self.entitlements = entitlements
        self.dependencies = dependencies
        self.ignoreDependencies = ignoreDependencies
        self.prioritizeDependencies = prioritizeDependencies
        self.settings = settings
        self.buildableFolders = buildableFolders
        self.sources = sources?.sourceFiles ?? []
        self.playgrounds = playgrounds
        self.resources = resources?.resources ?? []
        self.copyFiles = copyFiles ?? []
        self.headers = headers
        self.scripts = scripts
        self.coreDataModels = coreDataModels
        self.environmentVariables = environmentVariables
        self.launchArguments = launchArguments
        self.deploymentTargets = deploymentTargets ?? .empty()
        self.additionalFiles = additionalFiles
        self.preCreatedFiles = preCreatedFiles
        self.buildRules = buildRules
        self.mergedBinaryType = mergedBinaryType
        self.mergeable = mergeable
        self.filesGroup = filesGroup
        
        // Internal
        self.prune = false
    }

    // MARK: - Equatable

    public static func == (lhs: Target, rhs: Target) -> Bool {
        lhs.name == rhs.name && lhs.destinations == rhs.destinations && lhs.product == rhs.product && lhs.bundleId == rhs.bundleId && lhs.productName == rhs.productName
            && lhs.infoPlist == rhs.infoPlist && lhs.entitlements == rhs.entitlements && lhs.settings == rhs.settings && lhs.sources == rhs.sources
            && lhs.resources == rhs.resources && lhs.headers == rhs.headers && lhs.coreDataModels == rhs.coreDataModels && lhs.scripts == rhs.scripts
            && lhs.dependencies == rhs.dependencies && lhs.mergedBinaryType == rhs.mergedBinaryType && lhs.mergeable == rhs.mergeable
            && lhs.environmentVariables == rhs.environmentVariables
    }

    // MARK: - Hashable

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(destinations)
        hasher.combine(product)
        hasher.combine(bundleId)
        hasher.combine(productName)
        hasher.combine(environmentVariables)
    }

    // MARK: - Comparable

    public static func < (lhs: Target, rhs: Target) -> Bool {
        lhs.name < rhs.name
    }

    // MARK: - Encodable

    public func encode(to encoder: Encoder) throws {
        var c = encoder.container(keyedBy: CodingKeys.self)

        try c.encode(name, forKey: .name)
        try c.encode(destinations, forKey: .destinations)
        try c.encode(product, forKey: .product)
        try c.encode(productName, forKey: .productName)
        try c.encodeIfNotNil(bundleId, forKey: .bundleId)
        if deploymentTargets != .empty() {
            try c.encode(deploymentTargets, forKey: .deploymentTargets)
        }
        try c.encodeIfNotNil(infoPlist, forKey: .infoPlist)
        try c.encodeIfNotEmpty(buildableFolders, forKey: .buildableFolders)
        try c.encodeIfNotEmpty(sources, forKey: .sources)
        try c.encodeIfNotEmpty(playgrounds, forKey: .playgrounds)
        try c.encodeIfNotEmpty(resources, forKey: .resources)
        try c.encodeIfNotEmpty(copyFiles, forKey: .copyFiles)
        try c.encodeIfNotNil(headers, forKey: .headers)
        try c.encodeIfNotNil(entitlements, forKey: .entitlements)
        try c.encodeIfNotEmpty(scripts, forKey: .scripts)
        try c.encodeIfNotEmpty(dependencies, forKey: .dependencies)
        try c.encodeIfNotEmpty(ignoreDependencies, forKey: .ignoreDependencies)
        try c.encodeIfNotEmpty(prioritizeDependencies, forKey: .prioritizeDependencies)
        try c.encodeIfNotNil(settings, forKey: .settings)
        try c.encodeIfNotEmpty(coreDataModels, forKey: .coreDataModels)
        try c.encodeIfNotEmpty(environmentVariables, forKey: .environmentVariables)
        try c.encodeIfNotEmpty(launchArguments, forKey: .launchArguments)
        try c.encodeIfNotEmpty(additionalFiles, forKey: .additionalFiles)
        try c.encodeIfNotEmpty(preCreatedFiles, forKey: .preCreatedFiles)
        try c.encodeIfNotEmpty(buildRules, forKey: .buildRules)
        try c.encode(mergedBinaryType, forKey: .mergedBinaryType)
        try c.encode(mergeable, forKey: .mergeable)
        try c.encode(filesGroup, forKey: .filesGroup)
        try c.encode(prune, forKey: .prune)
    }

    // MARK: - Decodable

    public init(from decoder: Decoder) throws {
        let c = try decoder.container(keyedBy: CodingKeys.self)

        name = try c.decode(String.self, forKey: .name)
        destinations = try c.decode(Destinations.self, forKey: .destinations)
        product = try c.decode(Product.self, forKey: .product)
        productName = try c.decode(String.self, forKey: .productName)
        bundleId = try c.decodeIfPresent(String.self, forKey: .bundleId)
        deploymentTargets = try c.decodeIfPresent(DeploymentTargets.self, forKey: .deploymentTargets) ?? .empty()
        infoPlist = try c.decodeIfPresent(InfoPlist.self, forKey: .infoPlist)
        buildableFolders = try c.decodeIfPresent([BuildableFolder].self, forKey: .buildableFolders) ?? []
        sources = try c.decodeIfPresent([SourceFiles].self, forKey: .sources) ?? []
        playgrounds = try c.decodeIfPresent([FilePath].self, forKey: .playgrounds) ?? []
        resources = try c.decodeIfPresent([ResourceFileElement].self, forKey: .resources) ?? []
        copyFiles = try c.decodeIfPresent([CopyFilesAction].self, forKey: .copyFiles) ?? []
        headers = try c.decodeIfPresent(HeadersList.self, forKey: .headers)
        entitlements = try c.decodeIfPresent(Entitlements.self, forKey: .entitlements)
        scripts = try c.decodeIfPresent([TargetScript].self, forKey: .scripts) ?? []
        dependencies = try c.decodeIfPresent([TargetDependency].self, forKey: .dependencies) ?? []
        ignoreDependencies = try c.decodeIfPresent([TargetDependency].self, forKey: .ignoreDependencies) ?? []
        prioritizeDependencies = try c.decodeIfPresent([TargetDependency].self, forKey: .prioritizeDependencies) ?? []
        settings = try c.decodeIfPresent(Settings.self, forKey: .settings)
        coreDataModels = try c.decodeIfPresent([CoreDataModel].self, forKey: .coreDataModels) ?? []
        environmentVariables = try c.decodeIfPresent([String: EnvironmentVariable].self, forKey: .environmentVariables) ?? [:]
        launchArguments = try c.decodeIfPresent([LaunchArgument].self, forKey: .launchArguments) ?? []
        additionalFiles = try c.decodeIfPresent([FileElement].self, forKey: .additionalFiles) ?? []
        preCreatedFiles = try c.decodeIfPresent([String].self, forKey: .preCreatedFiles) ?? []
        buildRules = try c.decodeIfPresent([BuildRule].self, forKey: .buildRules) ?? []
        mergedBinaryType = try c.decode(MergedBinaryType.self, forKey: .mergedBinaryType)
        mergeable = try c.decode(Bool.self, forKey: .mergeable)
        filesGroup = try c.decodeIfPresent(ProjectGroup.self, forKey: CodingKeys.filesGroup) ?? .group(name: "Project")
        prune = try c.decodeIfPresent(Bool.self, forKey: .prune) ?? false
    }
}
